# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.
import logging
import datetime
from dateutil.relativedelta import relativedelta
from odoo import models, fields, _
from odoo.tools import DEFAULT_SERVER_DATE_FORMAT, date_utils
from babel.dates import get_quarter_names
from odoo.tools.misc import formatLang, format_date
from odoo.exceptions import UserError
# from datetime import datetime

_logger = logging.getLogger(__name__)


class AccountReport(models.AbstractModel):
    _inherit = 'account.report'

    def _get_dates_period(self, options, date_from, date_to, period_type=None):
        '''Compute some information about the period:
        * The name to display on the report.
        * The period type (e.g. quarter) if not specified explicitly.

        :param options:     The report options.
        :param date_from:   The starting date of the period.
        :param date_to:     The ending date of the period.
        :param period_type: The type of the interval date_from -> date_to.
        :return:            A dictionary containing:
            * date_from * date_to * string * period_type *
        '''

        print("**date_from, date_to,", date_from, date_to, period_type )
        def match(dt_from, dt_to):
            if self.has_single_date_filter(options):
                return (date_to or date_from) == dt_to
            else:
                return (dt_from, dt_to) == (date_from, date_to)

        string = None
        # If no date_from or not date_to, we are unable to determine a period
        if not date_from:
            date_from = fields.Datetime.now().date()
        if not date_to:
            date_to = fields.Datetime.now().date()
            
        if not period_type:
            date = date_to or date_from
            print("!!!!!!!!!!!!", date)

            company_fiscalyear_dates = self.env.user.company_id.compute_fiscalyear_dates(date)
            if match(company_fiscalyear_dates['date_from'], company_fiscalyear_dates['date_to']):
                period_type = 'fiscalyear'
                if company_fiscalyear_dates.get('record'):
                    string = company_fiscalyear_dates['record'].name
            elif match(*date_utils.get_month(date)):
                period_type = 'month'
            elif match(*date_utils.get_quarter(date)):
                period_type = 'quarter'
            elif match(*date_utils.get_fiscal_year(date)):
                period_type = 'year'
            else:
                period_type = 'custom'

        if not string:
            dt_from_str = format_date(self.env, date_from.strftime(DEFAULT_SERVER_DATE_FORMAT))
            print("dt_from_str", dt_from_str, date_from)
            fy_day = self.env.user.company_id.fiscalyear_last_day
            fy_month = self.env.user.company_id.fiscalyear_last_month
            if self.has_single_date_filter(options):
                string = _('As of %s') % (format_date(self.env, date_to.strftime(DEFAULT_SERVER_DATE_FORMAT)))
            elif period_type == 'year' or (period_type == 'fiscalyear' and (date_from, date_to) == date_utils.get_fiscal_year(date_to)):
                string = date_to.strftime('%Y')
            elif period_type == 'fiscalyear' and (date_from, date_to) == date_utils.get_fiscal_year(date_to, day=fy_day, month=fy_month):
                string = '%s - %s' % (date_to.year - 1, date_to.year)
            elif period_type == 'month':
                string = format_date(self.env, date_to.strftime(DEFAULT_SERVER_DATE_FORMAT), date_format='MMM YYYY')
            elif period_type == 'quarter':
                quarter_names = get_quarter_names('abbreviated', locale=self.env.context.get('lang') or 'en_US')
                string = u'%s\N{NO-BREAK SPACE}%s' % (quarter_names[date_utils.get_quarter_number(date_to)], date_to.year)
            else:
                dt_from_str = format_date(self.env, date_from.strftime(DEFAULT_SERVER_DATE_FORMAT))
                dt_to_str = format_date(self.env, date_to.strftime(DEFAULT_SERVER_DATE_FORMAT))
                string = _('From %s \n to  %s') % (dt_from_str, dt_to_str)

        return {
            'string': string,
            'period_type': period_type,
            'date_from': date_from,
            'date_to': date_to,
        }

    # def _get_dates_previous_period(self, options, period_vals):
    #     '''Shift the period to the previous one.

    #     :param options:     The report options.
    #     :param period_vals: A dictionary generated by the _get_dates_period method.
    #     :return:            A dictionary containing:
    #         * date_from * date_to * string * period_type *
    #     '''
    #     period_type = period_vals['period_type']
    #     date_from = period_vals['date_from']
    #     date_to = period_vals['date_to']

    #     if not date_from or not date_to:
    #         date = (date_from or date_to).replace(day=1) - datetime.timedelta(days=1)
    #         # Propagate the period_type to avoid bad behavior.
    #         # E.g. custom single date 2018-01-30 with previous period will produce 2017-12-31 that
    #         # must not be interpreted as a fiscal year.
    #         return self._get_dates_period(options, None, date, period_type=period_type)

    #     date_to = date_from - datetime.timedelta(days=1)
    #     print("date_from", date_from)
    #     print("date_to", date_to)
    #     if period_type == 'fiscalyear':
    #         # Don't pass the period_type to _get_dates_period to be able to retrieve the account.fiscal.year record if
    #         # necessary.
    #         company_fiscalyear_dates = self.env.user.company_id.compute_fiscalyear_dates(date_to)
    #         return self._get_dates_period(options, company_fiscalyear_dates['date_from'], company_fiscalyear_dates['date_to'])
    #     if period_type == 'month':
    #         return self._get_dates_period(options, *date_utils.get_month(date_to), period_type='month')
    #     if period_type == 'quarter':
    #         return self._get_dates_period(options, *date_utils.get_quarter(date_to), period_type='quarter')
    #     if period_type == 'year':
    #         return self._get_dates_period(options, *date_utils.get_fiscal_year(date_to), period_type='year')
    #     date_from = date_to - datetime.timedelta(days=(period_vals['date_to'] - date_from).days)
    #     return self._get_dates_period(options, date_from, date_to)

    # def _get_dates_previous_year(self, options, period_vals):
    #     '''Shift the period to the previous year.

    #     :param options:     The report options.
    #     :param period_vals: A dictionary generated by the _get_dates_period method.
    #     :return:            A dictionary containing:
    #         * date_from * date_to * string * period_type *
    #     '''
    #     period_type = period_vals['period_type']
    #     date_from = period_vals['date_from']
    #     date_to = period_vals['date_to']

    #     # Note: Use relativedelta to avoid moving from 2016-02-29 -> 2015-02-29 and then, have a day out of range.
    #     if not date_from or not date_to:
    #         date_to = date_from or date_to
    #         date_from = None

    #     date_to = date_to - relativedelta(years=1)
    #     # Take care about the 29th february.
    #     # Moving from 2017-02-28 -> 2016-02-28 is wrong! It must be 2016-02-29.
    #     if period_type == 'month':
    #         date_from, date_to = date_utils.get_month(date_to)
    #     elif date_from:
    #         date_from = date_from - relativedelta(years=1)
    #     return self._get_dates_period(options, date_from, date_to, period_type=period_type)

    # def format_value(self, value, currency=False):
    #     currency_id = currency or self.env.user.company_id.currency_id
    #     if self.env.context.get('no_format'):
    #         return currency_id.round(value)
    #     if currency_id.is_zero(value):
    #         # don't print -0.0 in reports
    #         value = abs(value)
    #     res = formatLang(self.env, value, currency_obj=currency_id)
    #     return res

    # def _apply_date_filter(self, options):
    #     print("options", options)
    #     def create_vals(period_vals):
    #         vals = {'string': period_vals['string']}
    #         if self.has_single_date_filter(options):
    #             vals['date'] = (period_vals['date_to'] or period_vals['date_from']).strftime(DEFAULT_SERVER_DATE_FORMAT)
    #         else:
    #             vals['date_from'] = period_vals['date_from'].strftime(DEFAULT_SERVER_DATE_FORMAT)
    #             vals['date_to'] = period_vals['date_to'].strftime(DEFAULT_SERVER_DATE_FORMAT)
    #         return vals

    #     # ===== Date Filter =====
    #     if not options.get('date') or not options['date'].get('filter'):
    #         return
    #     options_filter = options['date']['filter']

    #     date_from = None
    #     date_to = fields.Date.context_today(self)
    #     period_type = None
    #     if options_filter == 'custom':
    #         if self.has_single_date_filter(options):
    #             date_from = None
    #             date_to = fields.Date.from_string(options['date']['date'])
    #         else:
    #             date_from = fields.Date.from_string(options['date']['date_from'])
    #             date_to = fields.Date.from_string(options['date']['date_to'])
    #     elif 'today' in options_filter:
    #         if not self.has_single_date_filter(options):
    #             date_from = self.env.user.company_id.compute_fiscalyear_dates(date_to)['date_from']
    #     elif 'month' in options_filter:
    #         period_type = 'month'
    #         date_from, date_to = date_utils.get_month(date_to)
    #     elif 'quarter' in options_filter:
    #         period_type = 'quarter'
    #         date_from, date_to = date_utils.get_quarter(date_to)
    #     elif 'year' in options_filter:
    #         company_fiscalyear_dates = self.env.user.company_id.compute_fiscalyear_dates(date_to)
    #         date_from = company_fiscalyear_dates['date_from']
    #         date_to = company_fiscalyear_dates['date_to']
    #     else:
    #         raise UserError('Programmation Error: Unrecognized parameter %s in date filter!' % str(options_filter))

    #     period_vals = self._get_dates_period(options, date_from, date_to, period_type)
    #     print("period_vals" , period_vals)
    #     if 'last' in options_filter:
    #         period_vals = self._get_dates_previous_period(options, period_vals)

    #     options['date'].update(create_vals(period_vals))

    #     # ===== Comparison Filter =====
    #     if not options.get('comparison') or not options['comparison'].get('filter'):
    #         return
    #     cmp_filter = options['comparison']['filter']

    #     if cmp_filter == 'no_comparison':
    #         options['comparison']['string'] = _('No comparison')
    #         options['comparison']['periods'] = []
    #         if self.has_single_date_filter(options):
    #             options['comparison']['date'] = ""
    #         else:
    #             options['comparison']['date_from'] = ""
    #             options['comparison']['date_to'] = ""
    #         return

    #     if cmp_filter == 'custom':
    #         if self.has_single_date_filter(options):
    #             date_from = None
    #             date_to = fields.Date.from_string(options['comparison']['date'])
    #         else:
    #             date_from = fields.Date.from_string(options['comparison']['date_from'])
    #             date_to = fields.Date.from_string(options['comparison']['date_to'])
    #         vals = create_vals(self._get_dates_period(options, date_from, date_to))
    #         options['comparison']['periods'] = [vals]
    #         return

    #     periods = []
    #     number_period = options['comparison'].get('number_period', 1) or 0
    #     for index in range(0, number_period):
    #         if cmp_filter == 'previous_period':
    #             period_vals = self._get_dates_previous_period(options, period_vals)
    #         else:
    #             period_vals = self._get_dates_previous_year(options, period_vals)
    #         periods.append(create_vals(period_vals))

    #     if len(periods) > 0:
    #         options['comparison'].update(periods[0])
    #     options['comparison']['periods'] = periods
